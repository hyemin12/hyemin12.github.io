---
title: 소프트웨어 설계 - 디자인패턴
date: 2023-10-23 11:24:00 +09:00
categories: ["정보처리기사", "소프트웨어설계"]
tags: ["정보처리기사"]
toc: true
toc_sticky: true
---

<span style="color:#f00"></span>

## #디자인패턴 ★★★★★

공통으로 발생하는 문제에 대해 자주 쓰이는 설계 방법을 정리한 패턴

### ■ 디자인패턴 장점

- 요구 변경에 따른 소스 코드 변경을 최소화할 수 있게 해줌
- 소프트웨어 코드의 품질 향상
- 범용적인 코딩 스타일 적용 가능
- 개발자 간의 원활한 의사소통 가능
- 설계 변경 요청에 대한 유연한 대처가 가능
- 소프트웨어 구조 파악이 용이
- 객체 지향 설계 및 구현의 생산성을 높이는데 적합
- 재사용을 위한 개발 시간이 단축

### ■ 디자인패턴 단점

- 객체 지향 설계/구현 위주로 사용
- 초기 투자 비용의 부담

### ■ 디자인패턴 구성요소

### <span style="background-color:#ffdce0">@패문솔 사결샘</span>

- 패턴의 이름
- 문제 및 배경
- 솔루션
- 사례
- 결과
- 샘플코드

### ■ 디자인패턴 유형

### <span style="background-color:#ffdce0">@생구행</span>

### ★ 생성

### <span style="background-color:#ffdce0">@생빌 프로 팩앱싱</span>

#### ■ Builder (빌드)

- 복잡한 인스턴스를 조립하여 만드는 구조
- 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
- <span style="color:#f00">생성과 표기를 분리해서 복잡한 객체 생성</span>

#### ■ Prototype (프로토타입)

- 원형을 만들어 놓고 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴
- 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정
- <span style="color:#f00">기존 객체를 복제함으로써 객체를 생성</span>

#### ■ Factory Method (팩토리 메서드)

- <span style="color:#f00">상위클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스 생성하도록 하는 방식</span>
- 생성할 객체의 클래스를 국한하지 않고 객체 생성

#### ■ Abstract Factory (앱스트랙 팩토리)

- <span style="color:#f00">서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴</span>
- 동일한 주제의 다른 팩토리를 묶음

#### ■ Singleton (싱글톤)

- <span style="color:#f00">전역 변수를 사용하지 않고 객체 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인패턴</span>
- 한 클래스에 한 객체만 존재하도록 제한

### ★ 구조

### <span style="background-color:#ffdce0">@구 브데 퍼플 프록 컴 어</span>

#### ■ Bridge (브리지)

- <span style="color:#f00">추상과 구현을 분리하여 결합도를 낮춘 패턴</span>
- 구현뿐만 아니라 추상화된 부분까지 변경해야 하는 경우 활용

#### ■ Decorator (데코레이터)

- <span style="color:#f00">기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴</span>
- 객체의 결합을 통해 기능을 동적으로 유연하게 확장

#### ■ Facade (파사드)

- <span style="color:#f00">단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴</span>
- 오류에 대하여 단위별로 확인할 수 있게 해줌
- 사용자 측면에서 단순한 인터페이스 제공으로 접근성을 높일 수 있는 패턴
- 통합된 인터페이스 제공

#### ■ Flyweight (플라이 웨이트)

- 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리를 절약하고, '클래스의 경량화'를 목적으로 하는 디자인 패턴
- <span style="color:#f00">여러 개의 '가상 인스턴스'를 제공하여 메모리 절감</span>

#### ■ Proxy (프록시)

- '실체 객체에 대한 대리 객체'
- 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있음
- 실체 객체를 드러나지 않게 하여 정보 은닉의 역할도 수행
- <span style="color:#f00">특정 객체로의 접근을 제어</span>하기 위한 용도로 사용

#### ■ Composite (컴포지트)

- <span style="color:#f00">객체들의 관계를 트리구조로 구성하여 부분-전체 계층을 표현하는 패턴</span>
- 복합 객체와 단일 객체를 동일하게 취급

#### ■ Adapter (어댑터)

- <span style="color:#f00">기존에 생성된 클래스를 재사용할 수 있도록 중간에 맞춰주는 역할을 하는 인터페이스를 만드는 패턴</span>
- 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두가지 형태로 사용되는 디자인 패턴
- 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

### ★ 행위

#### ■ Mediator

- <span style="color:#f00">통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해주는 디자인 패턴</span>
- 상호 작용의 유연한 변경을 지원

#### ■ Interpreter

- <span style="color:#f00">여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴</span>
- 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴
- 문법 자체를 캡슐화하여 사용

#### ■ Interator

- 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 반복자를 사용하여 접근할 수 있는 디자인 패턴
- <span style="color:#f00">내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴</span>

#### ■ Template Method

- 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴

#### ■ Observer

- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법
- 일대 다의 의존성을 가짐
- 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴
- 객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대 다 의존

#### ■ State

- 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식
- 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지보수의 편의성도 갖는 디자인 패턴
- 객체의 상태에 따라 행위 내용을 변경

#### ■ Visitor

- 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고, 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴
- <span style="color:#f00">객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴</span>

#### ■ Command

- <span style="color:#f00">실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴</span>
- 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴

#### ■ Strategy

- <span style="color:#f00">알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴</span>
- 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있도록 해주는 패턴

#### ■ Memento

- 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 <span style="color:#f00">Undo(작업취소) 기능을 개발할 때 사용하는 디자인 패턴</span>

#### ■ Chain of Responsibility

- 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴
- 한 요청을 2개 이상 객체에서 처리
